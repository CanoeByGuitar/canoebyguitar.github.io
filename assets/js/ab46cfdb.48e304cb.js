"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1467],{3905:(n,e,t)=>{t.d(e,{Zo:()=>d,kt:()=>y});var a=t(7294);function r(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function i(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,a)}return t}function s(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?i(Object(t),!0).forEach((function(e){r(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function p(n,e){if(null==n)return{};var t,a,r=function(n,e){if(null==n)return{};var t,a,r={},i=Object.keys(n);for(a=0;a<i.length;a++)t=i[a],e.indexOf(t)>=0||(r[t]=n[t]);return r}(n,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);for(a=0;a<i.length;a++)t=i[a],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(r[t]=n[t])}return r}var l=a.createContext({}),o=function(n){var e=a.useContext(l),t=e;return n&&(t="function"==typeof n?n(e):s(s({},e),n)),t},d=function(n){var e=o(n.components);return a.createElement(l.Provider,{value:e},n.children)},m="mdxType",c={inlineCode:"code",wrapper:function(n){var e=n.children;return a.createElement(a.Fragment,{},e)}},u=a.forwardRef((function(n,e){var t=n.components,r=n.mdxType,i=n.originalType,l=n.parentName,d=p(n,["components","mdxType","originalType","parentName"]),m=o(t),u=r,y=m["".concat(l,".").concat(u)]||m[u]||c[u]||i;return t?a.createElement(y,s(s({ref:e},d),{},{components:t})):a.createElement(y,s({ref:e},d))}));function y(n,e){var t=arguments,r=e&&e.mdxType;if("string"==typeof n||r){var i=t.length,s=new Array(i);s[0]=u;var p={};for(var l in e)hasOwnProperty.call(e,l)&&(p[l]=e[l]);p.originalType=n,p[m]="string"==typeof n?n:r,s[1]=p;for(var o=2;o<i;o++)s[o]=t[o];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},630:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>i,metadata:()=>p,toc:()=>o});var a=t(7462),r=(t(7294),t(3905));const i={title:"\u6a21\u7248\u5143\u5165\u95e8",tags:["C++"]},s=void 0,p={permalink:"/blog/C++/\u6a21\u7248\u5143\u8303\u5f0f\u5165\u95e8/1",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/C++/\u6a21\u7248\u5143\u8303\u5f0f\u5165\u95e8/1.md",source:"@site/blog/C++/\u6a21\u7248\u5143\u8303\u5f0f\u5165\u95e8/1.md",title:"\u6a21\u7248\u5143\u5165\u95e8",description:"\u6a21\u7248\u7c7b\u578b\u63a8\u5bfc",date:"2024-08-05T16:57:03.000Z",formattedDate:"August 5, 2024",tags:[{label:"C++",permalink:"/blog/tags/c"}],readingTime:18.9,hasTruncateMarker:!0,authors:[],frontMatter:{title:"\u6a21\u7248\u5143\u5165\u95e8",tags:["C++"]},prevItem:{title:"\u5e38\u7528\u8bbe\u8ba1\u6a21\u5f0f",permalink:"/blog/C++/\u8bbe\u8ba1\u6a21\u5f0f/1"},nextItem:{title:"\u52a8\u6001\u591a\u6001\u548c\u9759\u6001\u591a\u6001",permalink:"/blog/C++/\u52a8\u6001\u591a\u6001\u548c\u9759\u6001\u591a\u6001/1"}},l={authorsImageUrls:[]},o=[{value:"\u6a21\u7248\u7c7b\u578b\u63a8\u5bfc",id:"\u6a21\u7248\u7c7b\u578b\u63a8\u5bfc",level:2},{value:"ParamType\u662f\u6307\u9488\u6216\u666e\u901a\u5f15\u7528\u7c7b\u578b",id:"paramtype\u662f\u6307\u9488\u6216\u666e\u901a\u5f15\u7528\u7c7b\u578b",level:3},{value:"ParamType\u662f\u901a\u7528\u5f15\u7528",id:"paramtype\u662f\u901a\u7528\u5f15\u7528",level:3},{value:"ParamType\u4e0d\u662f\u5f15\u7528/\u6307\u9488",id:"paramtype\u4e0d\u662f\u5f15\u7528\u6307\u9488",level:3},{value:"auto\u7c7b\u578b\u63a8\u5bfc",id:"auto\u7c7b\u578b\u63a8\u5bfc",level:2},{value:"\u6a21\u7248\u53c2\u6570",id:"\u6a21\u7248\u53c2\u6570",level:2},{value:"\u7c7b\u578b\u6a21\u7248\u53c2\u6570",id:"\u7c7b\u578b\u6a21\u7248\u53c2\u6570",level:3},{value:"\u6574\u6570",id:"\u6574\u6570",level:3},{value:"\u6a21\u7248\u7c7b\u578b\uff08\u6a21\u7248\u5d4c\u5957\uff09",id:"\u6a21\u7248\u7c7b\u578b\u6a21\u7248\u5d4c\u5957",level:3},{value:"\u53d8\u53c2\u6a21\u7248",id:"\u53d8\u53c2\u6a21\u7248",level:2},{value:"\u89e3\u5305\u65b9\u6cd5",id:"\u89e3\u5305\u65b9\u6cd5",level:3},{value:"\u6a21\u7248\u94fe\u63a5",id:"\u6a21\u7248\u94fe\u63a5",level:2},{value:"\u5199\u5728header\u4e2d\u7684\u539f\u56e0",id:"\u5199\u5728header\u4e2d\u7684\u539f\u56e0",level:3},{value:"\u6a21\u7248\u663e\u793a\u5b9e\u4f8b\u5316",id:"\u6a21\u7248\u663e\u793a\u5b9e\u4f8b\u5316",level:3},{value:"SFINAE",id:"sfinae",level:2},{value:"\u6a21\u7248\u5143\u7f16\u7a0b",id:"\u6a21\u7248\u5143\u7f16\u7a0b",level:2},{value:"\u9759\u6001\u8ba1\u7b97",id:"\u9759\u6001\u8ba1\u7b97",level:3},{value:"\u6574\u6570\u8fd0\u7b97",id:"\u6574\u6570\u8fd0\u7b97",level:4},{value:"\u903b\u8f91\u8fd0\u7b97",id:"\u903b\u8f91\u8fd0\u7b97",level:4},{value:"\u7c7b\u578b\u5904\u7406\uff08\u8403\u53d6\uff09\u3010type traits\u3011",id:"\u7c7b\u578b\u5904\u7406\u8403\u53d6type-traits",level:3},{value:"\u6761\u4ef6\u7c7b\u578b",id:"\u6761\u4ef6\u7c7b\u578b",level:4},{value:"\u8f85\u52a9\u5de5\u5177",id:"\u8f85\u52a9\u5de5\u5177",level:4},{value:"\u6848\u4f8b",id:"\u6848\u4f8b",level:2},{value:"\u5b9e\u73b0\u4e00\u4e2a\u52a8\u6001\u7684get",id:"\u5b9e\u73b0\u4e00\u4e2a\u52a8\u6001\u7684get",level:3},{value:"\u5b9e\u73b0\u4e00\u4e2astd::invoke",id:"\u5b9e\u73b0\u4e00\u4e2astdinvoke",level:3},{value:"\u5b9e\u73b0\u4e00\u4e2astd::apply",id:"\u5b9e\u73b0\u4e00\u4e2astdapply",level:3},{value:"\u5b9e\u73b0\u4e00\u4e2avariant",id:"\u5b9e\u73b0\u4e00\u4e2avariant",level:3}],d={toc:o},m="wrapper";function c(n){let{components:e,...t}=n;return(0,r.kt)(m,(0,a.Z)({},d,t,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"\u6a21\u7248\u7c7b\u578b\u63a8\u5bfc"},"\u6a21\u7248\u7c7b\u578b\u63a8\u5bfc"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename T>\nvoid f(ParamType param);\n\nf(expr)\n")),(0,r.kt)("p",null,"\u5bf9\u4e0a\u9762\u8fd9\u79cd\u5f62\u5f0f\uff0c\u4f9d\u636eParamType\u53ef\u4ee5\u5206\u4e3a\u4e09\u79cd\u60c5\u51b5"),(0,r.kt)("blockquote",null,(0,r.kt)("ol",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ol"},"ParamType\u662f\u6307\u9488\u6216\u5f15\u7528\u7c7b\u578b\uff0c\u4f46\u4e0d\u662f\u901a\u7528\u5f15\u7528\uff08Universal Reference\uff09\u3010\u901a\u7528\u5f15\u7528\u5e94\u8be5\u662fmodern effective c++\u7684\u4f5c\u8005\u63d0\u51fa\u6765\u7684\u6982\u5ff5\uff0c\u8868\u793a\u6a21\u7248\u4e2d&&\u9488\u5bf9\u4f20\u5165\u7684\u662f\u5de6\u503c\u8fd8\u662f\u53f3\u503c\u63d0\u4f9b\u4e0d\u540c\u7684\u6548\u679c\uff0c\u672c\u8d28cpp\u53ea\u6709\u5f15\u7528\u6298\u53e0\u3011"),(0,r.kt)("li",{parentName:"ol"},"ParamType\u662f\u901a\u7528\u5f15\u7528\uff08Universal Reference\uff09"),(0,r.kt)("li",{parentName:"ol"},"ParamType\u65e2\u4e0d\u662f\u6307\u9488\u4e5f\u4e0d\u662f\u5f15\u7528"))),(0,r.kt)("h3",{id:"paramtype\u662f\u6307\u9488\u6216\u666e\u901a\u5f15\u7528\u7c7b\u578b"},"ParamType\u662f\u6307\u9488\u6216\u666e\u901a\u5f15\u7528\u7c7b\u578b"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"/// \u5f15\u7528\ntemplate<typename T>\nvoid f(T& param);\n\nint x = 27;\nconst int cx = x;\nconst int& rx = x;\n\nf(x); // T is int, ParamType is int&\nf(cx); // T is const int, ParamType is const int&\nf(rx); // T is const int, ParamType is const int&\n\n\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"const\u4fee\u9970\u4f1a\u8ddf\u968f\u4f20\u9012\u8fdb\u6a21\u7248\u53c2\u6570T\uff1b\u4f46\u662f\u5f15\u7528\u4fee\u9970\u4f1a\u88ab\u5ffd\u7565\uff08\u6307\u9488\u4e0e\u5f15\u7528\u7c7b\u4f3c\uff09")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename T>\nvoid f(const T& param);\n\nint x = 27;\nconst int cx = x;\nconst int& rx = x;\n\nf(x); // T is int, ParamType is const int&\nf(cx); // T is int, ParamType is const int&\nf(rx); // T is int, ParamType is const int&\n")),(0,r.kt)("h3",{id:"paramtype\u662f\u901a\u7528\u5f15\u7528"},"ParamType\u662f\u901a\u7528\u5f15\u7528"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"templat<typename T>\nvoid f(T&& param);\n\nint x = 27;\nconst int cx = x;\nconst int& rx = x;\n\nf(x); // x is lvalue, T is int&, ParamType is int&\nf(cx); // x is lvalue, T is const int&, ParamType is const int&\nf(rx); // x is lvalue, T is const int&, ParamType is const int&\nf(27); // x is rvalue, T is int, ParamType is int&&\n")),(0,r.kt)("p",null,"\u5982\u679c\u4f20\u5165f\u7684\u662f\u4e2a\u5de6\u503c\uff0cT\u548cParamType\u90fd\u4f1a\u88ab\u63a8\u5bfc\u4e3a\u5de6\u503c\u5f15\u7528"),(0,r.kt)("p",null,"\u5982\u679c\u4f20\u5165f\u7684\u662f\u53f3\u503c\uff0c \u89c4\u5219\u540ccase1"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"\u5f15\u7528\u6298\u53e0\uff1f&\u4f20\u7ed9 && \u6216\u8005 && \u4f20\u7ed9& \u90fd\u4f1a\u53d8\u6210&\uff1b && \u4f20\u7ed9&&\u8fd8\u662f&&")),(0,r.kt)("h3",{id:"paramtype\u4e0d\u662f\u5f15\u7528\u6307\u9488"},"ParamType\u4e0d\u662f\u5f15\u7528/\u6307\u9488"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"templat<typename T>\nvoid f(T param);\n\nint x = 27;\nconst int cx = x;\nconst int& rx = x;\nint* y = x;\n\nf(x); // T is int, ParamType is int\nf(cx); // T is int, ParamType is int\nf(rx); // T is int, ParamType is int\nf(y); // T is int*, ParamType is int*\n")),(0,r.kt)("p",null,"\u4f20\u5f15\u7528\uff0c\u503c\u4f20\u9012\uff0c\u51fd\u6570\u4e2d\u7684T\u76f8\u5f53\u4e8e\u662f\u4e2a\u6df1\u62f7\u8d1d\uff0c\u56e0\u6b64T\u4e0d\u4f1a\u5e26const"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u4f20\u6307\u9488\u8fdb\u53bb\u4f1a\u89e3\u6790\u6210\u6307\u9488\u7c7b\u578b")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"struct A {\nint x = 0;\n};\n\n\ntemplate<typename T>\nvoid f1(T a){\n    a.x = 1;\n}\n\ntemplate<typename T>\nvoid f2(T& a){\n    a.x = 2;\n}\n\nint main() {\n    A a;\n    A& a1 = a;\n    A& a2 = a;\n\n    // auto a11 = a;  auto = A, a1 is A\n    f1(a1);\n    std::cout << a1.x << std::endl;\n\n    // auto& a22 = a;  auto = A, a22 is A&\n    f2(a2);\n    std::cout << a2.x << std::endl;\n}\n")),(0,r.kt)("h2",{id:"auto\u7c7b\u578b\u63a8\u5bfc"},"auto\u7c7b\u578b\u63a8\u5bfc"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"}," auto type deduction ",(0,r.kt)("em",{parentName:"p"},"is")," template type deduction")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// auto x = 27; \u7b49\u4ef7\u4e8e\ntemplate<typename T>\nvoid f(T param);\nf(27);  // auto = T = int\n\n// const auto cx = x; \u7b49\u4ef7\u4e8e\ntemplate<typename T>\nvoid f(const T param);\nf(cx);  // auto = T = int\n\n// const auto& rx = x;\ntemplate<typename T>\nvoid f(const T& param);\nf(rx);  // auto = T = int\n\n// auto&& y = std::move(x)\ntemplate<typename T>\nvoid f(T&& param);\nf(y); // auto = T = int, ParamType = int&&\n")),(0,r.kt)("p",null,"\u4e3a\u4ec0\u4e48\u4e0b\u9762\u4e24\u4e2a\u90fd\u53ef\u4ee5"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int main() {\n    auto a1 = new A; // case 3\n    delete a1;\n\n    auto* a2 = new A; // case 1\n    delete a2;\n}\n")),(0,r.kt)("h2",{id:"\u6a21\u7248\u53c2\u6570"},"\u6a21\u7248\u53c2\u6570"),(0,r.kt)("p",null,"\u6a21\u7248\u53c2\u6570\u4e3b\u8981\u6709\u4e09\u79cd"),(0,r.kt)("blockquote",null,(0,r.kt)("ol",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ol"},"\u7c7b\u578b"),(0,r.kt)("li",{parentName:"ol"},"\u6574\u6570\u548c\u6574\u6570\u7684\u884d\u751f\u7c7b\u578b"),(0,r.kt)("li",{parentName:"ol"},"\u6a21\u7248"))),(0,r.kt)("h3",{id:"\u7c7b\u578b\u6a21\u7248\u53c2\u6570"},"\u7c7b\u578b\u6a21\u7248\u53c2\u6570"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename T>\nvoid print(const T& t){\n    std::cout << t << std::endl;\n}\n\nprint(1);\nint x = 1;\nprint(x);\n")),(0,r.kt)("h3",{id:"\u6574\u6570"},"\u6574\u6570"),(0,r.kt)("p",null,"\u5fc5\u987b\u7f16\u8bd1\u671f\u786e\u5b9a\u7684\u503c"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template <int* p>\nvoid f(int data){\n    *p = data;\n}\n\nint g = 1;\n\nstruct A{\n    int m1;\n    static int m2;\n};\n\nint A::m2 = 1;\n\nint main(){\n    f<&g>(0);\n    f<&A::m2>(0);\n\n    static int c = 3;\n    f<&A::m2>(0);\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u6574\u6570\u884d\u751f\u7c7b\u578b")),(0,r.kt)("p",null,"\u5730\u5740\u5728\u7f16\u8bd1\u671f\u80af\u5b9a\u4e0d\u77e5\u9053\uff0c\u4f46\u662f\u53ea\u8981\u4fdd\u8bc1\u67d0\u4e2a\u5730\u5740\u7684\u6570\u636e\u5728\u8fd0\u884c\u671f\u95f4\u662f\u4e0d\u53d8\u7684\uff0c\u5c31\u53ef\u4ee5\u7528\u8fd9\u79cd\u65b9\u5f0f"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template <int* p>\nvoid f(int data){\n    *p = data;\n}\n\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u51fd\u6570\u6307\u9488")),(0,r.kt)("p",null,"\u56e0\u4e3a\u51fd\u6570\u5730\u5740\u5728\u7a0b\u5e8f\u6bb5\uff0c\u6267\u884c\u8fc7\u7a0b\u5c31\u4e0d\u4f1a\u53d8\uff0c\u6240\u4ee5\u53ef\u4ee5\u7528\u4f5c\u6a21\u7248\u53c2\u6570"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'//\n// Created by ChenhuiWang on 2024/3/28.\n\n// Copyright (c) 2024 Tencent. All rights reserved.\n//\n#include "iostream"\n#include <vector>\n\ntemplate <void (*func)()>\nvoid f(){\n    func();\n}\n\nvoid f1(){}\n\nstruct A{\n    void f2(){}\n    static void f3(){}\n};\n\nint main(){\n    constexpr void (*pf1)() = &f1;\n\n    f<&f1>();\n    f<pf1>();\n    f<&A::f2>(); //error: &A::f2\u7684\u7c7b\u578b\u662fvoid (Test::*)()\n    f<&A::f3>();\n}\n')),(0,r.kt)("h3",{id:"\u6a21\u7248\u7c7b\u578b\u6a21\u7248\u5d4c\u5957"},"\u6a21\u7248\u7c7b\u578b\uff08\u6a21\u7248\u5d4c\u5957\uff09"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template <template<typename, typename> typename Tem>\nvoid f(){\n    Tem<int, std::string> te;\n    te.show();\n}\n\ntemplate<typename T1, typename T2>\nstruct A1{\n    void show(){\n        std::cout << 1 << std::endl;\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct A2{\n    void show(){\n        std::cout << 2 << std::endl;\n    }\n};\n\nint main(){\n    f<A1>(); //A1\u5b9e\u4f8b\u5316\u524d\u5728\u662ftemplate\u7c7b\u578b\n    f<A2>();\n}\n")),(0,r.kt)("h2",{id:"\u53d8\u53c2\u6a21\u7248"},"\u53d8\u53c2\u6a21\u7248"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename... Ts>\nauto sum(Ts... ts){\n    return (ts + ...);\n}\n\nint main(){\n    sum(1, 2);\n    sum(1.0, 2);\n}\n")),(0,r.kt)("p",null,"typename... \u8868\u793a\u5305pack\uff0c \u5305\u540d\u4e3aTs\uff0c Ts... \u8868\u793a\u5bf9Ts\u8fdb\u884c\u89e3\u5305\uff0c \u5fc5\u987b\u5728\u53c2\u6570\u5217\u8868\u7684\u6700\u540e\u3002"),(0,r.kt)("p",null,"Ts\u53ef\u4ee5\u4e3a\u7a7a"),(0,r.kt)("h3",{id:"\u89e3\u5305\u65b9\u6cd5"},"\u89e3\u5305\u65b9\u6cd5"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"\u76f4\u63a5\u5c55\u5f00,\u5305\u4f1a\u88ab\u7f16\u8bd1\u5668\u5c55\u5f00\u4e3a\u9017\u53f7\u95f4\u9694\u7684\u53c2\u6570")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"std::byte memory[16384];\nvoid* head = memory;\n\ntemplate<typename T, typename... Args>\nT& create(Args... args){\n    auto& obj = *new(head) T(args...); // use operator new\n    head += sizeof(T);\n    return obj;\n}\n\nstruct A{\n    A(int, double){}\n}\n\nint main(){\n    auto a = Create<A, int, double>(1, 2.5);\n}\n\n// \u6a21\u7248\u5b9e\u4f8b\u5316\u540e\u4f1a\u8fd9\u6837\nA& create(int arg1, double arg2){\n    auto& obj = *new(head) A(arg1, arg2);\n    head += sizeof(T);\n    return obj;\n}\n    \n")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"\u5d4c\u5957\u5c55\u5f00")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename T, int... N>\nstd::vector<T> GetSubVector(const std::vector<T>& src){\n    return std::vector<T>{src.at(N)...}\n}\n")),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},"\u6309\u7167\u7b26\u53f7\u5c55\u5f00\uff08c++ 17\uff09\u6298\u53e0\u8868\u8fbe\u5f0f")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// c++17\u4e4b\u524d\ntemplate<typename T>\nauto sum(T arg){\n    return arg;\n}\n\ntemplate<typename T, typename... Ts>\nauto sum(T t, Ts... ts){\n    return t + sum<Ts...>(ts);\n}\n\nsum<int, double, float, short>(1, 1.0, 2.0, 3);\n==> 1 + sum<double, float, short>(1.0, 2.0, 3);\n==> 1 + 1.0 + sum<float, short>(2.0, 3);\n==> 1 + 1.0 + 2.0 + sum<short>(3);\n==> 1 + 1.0 + 2.0 + 3\n\n// c++17 \u4e4b\u540e\ntemplate<typename T>\nauto sum(T... ts){\n    // \u4e09\u4e2a\u70b9\u5728\u5de6\u8fb9\uff0c \u8868\u793a\u4ece\u5de6\u5230\u53f3\u5408\u5e76\n    // \u6298\u53e0\u8868\u8fbe\u5f0f\u5fc5\u987b\u8981\u6709\u62ec\u53f7\n    return (... + ts); \n}\n")),(0,r.kt)("h2",{id:"\u6a21\u7248\u94fe\u63a5"},"\u6a21\u7248\u94fe\u63a5"),(0,r.kt)("h3",{id:"\u5199\u5728header\u4e2d\u7684\u539f\u56e0"},"\u5199\u5728header\u4e2d\u7684\u539f\u56e0"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// a.h\ntemplate<typename T>\nvoid f();\n\n// a.cpp\n// \u5982\u679c\u628a\u8fd9\u4e2a\u5199\u8fdba.h\u5c31\u4e0d\u4f1a\u62a5\u9519\u4e86\uff0c\u5e76\u4e14\u5982\u679ca.h\u88ab\u591a\u6587\u4ef6include\uff0c\u4e0d\u4f1a\u4ea7\u751fmulti defined\n// \u56e0\u4e3a\u672a\u5b9e\u4f8b\u5316\u7684\u6a21\u7248\u662f\u81ea\u52a8inline\u7684\n// \u6ce8\u610f\u5168\u7279\u5316\u7684\u8bdd\u5c31\u4e0d\u4f1a\u81ea\u52a8inline\u4e86\uff0c\u4ed6\u662f\u5b9e\u4f8b\u5316\u540e\u7684\u6a21\u7248\u51fd\u6570\ntemplate<typename T>\nvoid f(){\n    \n}\n\n// main.cpp\n#include <a.h>\nint main(){\n    f<int>();\n}\n\n\n")),(0,r.kt)("p",null,"\u4ea7\u751f\u4e24\u4e2a\u7f16\u8bd1\u5355\u5143 main.o\u548ca.o"),(0,r.kt)("p",null,"main.o\u4e2d",(0,r.kt)("inlineCode",{parentName:"p"},"void  f<int>();")," \u53bb\u5176\u4ed6\u5730\u65b9\u627e\u5b9e\u73b0\uff0c\u4f46\u662fa.o\u4e2d\u6ca1\u6709\u4f7f\u7528",(0,r.kt)("inlineCode",{parentName:"p"},"f<int>"),"\u5c31\u4e0d\u4f1a\u4ea7\u751f\u76f8\u5e94\u7684\u51fd\u6570\u88ab\u94fe\u63a5\u4e86\u3002"),(0,r.kt)("h3",{id:"\u6a21\u7248\u663e\u793a\u5b9e\u4f8b\u5316"},"\u6a21\u7248\u663e\u793a\u5b9e\u4f8b\u5316"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// a.h\ntemplate<typename T>\nvoid f();\n\n// a.cpp\ntemplate<typename T>\nvoid f(){}\n\n// \u663e\u5f0f\u5b9e\u4f8b\u5316\ntemplate f<int>();\n\n// main.cpp\n#include <a.h>\nint main(){\n    f<int>();\n}\n\n")),(0,r.kt)("h2",{id:"sfinae"},"SFINAE"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Substitution Failure Is Not An Error")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'//\n// Created by ChenhuiWang on 2024/3/29.\n\n// Copyright (c) 2024 Tencent. All rights reserved.\n//\n#include <iostream>\n\ntemplate<typename T, bool Condition>\nstruct EnableIf{};\n\ntemplate<typename T>\nstruct EnableIf<T, true>{\n    using type = T;\n};\n\ntemplate<typename T>\nvoid f(typename EnableIf<T, sizeof(T) <= sizeof(void*)>::type t){\n    std::cout << "1" << std::endl;\n}\n\ntemplate<typename T>\nvoid f(typename EnableIf<T, (sizeof(T) > sizeof(void*))>::type t){\n    std::cout << "2" << std::endl;\n}\n\nstruct A{\n    int data[16];\n};\nvoid Demo(){\n    f<int>(1);\n    A a;\n    f<A>(a);\n}\n\n//\u5b9e\u4f8b\u5316\u8fc7\u7a0b,\u8fdb\u884c\u6a21\u7248\u5339\u914d\nf<int>(1)\n    ==> void f(typename EnableIf<T, sizeof(T) <= sizeof(void*)>::type t)\n    ==> \u547d\u4e2dEnableIf\u7684EnableIf<T, true>\u7684\u7279\u5316\u7248\u672c\n    ==> f(int)\n\nf<A>(a)\n    ==> void f(typename EnableIf<T, sizeof(T) <= sizeof(void*)>::type t)\n    ==> \u6ca1\u6709\u8fd9\u4e2a\u7279\u5316\u7248\u672c\uff0c\u56de\u5f52\u5230\u901a\u7528\u6a21\u7248template<typename T, bool Condition> struct EnableIf{};\n    ==> \u901a\u7528\u7248\u672c\u6ca1\u6709::type, \u5339\u914d\u5931\u8d25\n    ==> \u7ee7\u7eed\u5339\u914d void f(typename EnableIf<T, sizeof(T) > sizeof(void*)>::type t)\n    ==> \u547d\u4e2dEnableIf\u7684EnableIf<T, true>\u7684\u7279\u5316\u7248\u672c\n    ==> f(A)\n')),(0,r.kt)("p",null,"\u8fd9\u91cc\u7684enable_if\u662fstd::enable_if\u7684\u7b80\u5316\u7248\u3002"),(0,r.kt)("p",null,"SFINAE\u662f\u6a21\u7248\u5143\u7f16\u7a0b\u6700\u91cd\u8981\u7684\u7406\u8bba\u57fa\u7840\uff0c\u6838\u5fc3\u5728\u4e8e\u3010\u6784\u9020\u4e00\u79cd\u6a21\u5f0f\uff0c\u8ba9\u5176\u5339\u914d\u6210\u529f\u6216\u5931\u8d25\u3011"),(0,r.kt)("h2",{id:"\u6a21\u7248\u5143\u7f16\u7a0b"},"\u6a21\u7248\u5143\u7f16\u7a0b"),(0,r.kt)("p",null,"\u6a21\u7248\u5143\u5c31\u662f",(0,r.kt)("strong",{parentName:"p"},"\u9759\u6001\u8ba1\u7b97+\u7c7b\u578b\u5904\u7406")),(0,r.kt)("h3",{id:"\u9759\u6001\u8ba1\u7b97"},"\u9759\u6001\u8ba1\u7b97"),(0,r.kt)("h4",{id:"\u6574\u6570\u8fd0\u7b97"},"\u6574\u6570\u8fd0\u7b97"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<int N>\nstruct Fib{\n    constexpr static int value = Fib<N - 2>::value + Fib<N - 1>::value;\n};\n\ntemplate<>\nstruct Fib<0>{\n    constexpr static int value = 1;\n};\n\ntemplate<>\nstruct Fib<1>{\n    constexpr static int value = 1;\n};\n\nint main(){\n    int a[Fib<10>::value];\n}\n")),(0,r.kt)("h4",{id:"\u903b\u8f91\u8fd0\u7b97"},"\u903b\u8f91\u8fd0\u7b97"),(0,r.kt)("p",null,"\u66f4\u591a\u7684\u662f\u5bf9\u7c7b\u578b\u8fdb\u884c\u5224\u65ad"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename T1, typename T2>\nstruct is_same{\n    constexpr static bool value = false;\n};\n\ntemplate<typename T>\nstruct is_same<T, T> {\n    constexpr static bool value = true;\n};\n\ntemplate<typename T>\ntypename std::enable_if<is_same<T, int>::value, void>::type\nf(T t){}\n")),(0,r.kt)("p",null,"\u5199\u8d77\u6765\u6bd4\u8f83\u5570\u55e6\uff0c\u6240\u4ee5\u66f4\u591a\u662f\u8fd9\u6837"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename T, T val>\nstruct integer_const{\n    constexpr static T value = val;\n}\n\ntemplate<bool val>\nusing bool_constant = integer_constant<bool, val>;\n")),(0,r.kt)("h3",{id:"\u7c7b\u578b\u5904\u7406\u8403\u53d6type-traits"},"\u7c7b\u578b\u5904\u7406\uff08\u8403\u53d6\uff09\u3010type traits\u3011"),(0,r.kt)("h4",{id:"\u6761\u4ef6\u7c7b\u578b"},"\u6761\u4ef6\u7c7b\u578b"),(0,r.kt)("p",null,"std::conditional"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'template<bool cond, typename T1, typename T2>\nstruct conditional {\n    using type = T1;\n};\n\ntemplate<typename T1, typename T2>\nstruct conditional<false, T1, T2>{\n    using type = T2;\n};\n\ntemplate <typename T>\nvoid f(typename conditional<std::is_fundamental<T>::value, T, const T&>::type t){\n\n}\n\nvoid Demo(){\n    int a = 0;\n    std::string str = "abc";\n    f<int>(a);\n    f<std::string>(str);\n}\n')),(0,r.kt)("h4",{id:"\u8f85\u52a9\u5de5\u5177"},"\u8f85\u52a9\u5de5\u5177"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template <bool cond, typename T1, typename T2>\nusing conditional_t = typename conditional<cond, T1, T2>::type;\n\ntemplate <typename T>\nvoid f(conditional_t<std::is_fundamental<T>::value, T, const T&> t){\n\n}\n")),(0,r.kt)("h2",{id:"\u6848\u4f8b"},"\u6848\u4f8b"),(0,r.kt)("h3",{id:"\u5b9e\u73b0\u4e00\u4e2a\u52a8\u6001\u7684get"},"\u5b9e\u73b0\u4e00\u4e2a\u52a8\u6001\u7684get"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// std::get\u8fd4\u56de\u503c\u7c7b\u578b\u5728\u7f16\u8bd1\u671f\u5c31\u662f\u786e\u5b9a\u7684\nstd::tuple<int, std::string, float> tp = {1, "1", 1.0};\nstd::cout << std::get<0>(tp);\n\n// \u5982\u4f55\u5b9e\u73b0\u4e00\u4e2a\u52a8\u6001\u7684get, \u6bd4\u5982get(tp, i)\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"\n//\n// Created by ChenhuiWang on 2024/4/11.\n\n// Copyright (c) 2024 Tencent. All rights reserved.\n//\n#include <tuple>\n#include <string>\n#include <iostream>\n\nstruct Base {\n    virtual void f() const = 0;\n};\n\nstruct D1 : public Base {\n    void f() const override {\n    }\n};\n\nstruct D2 : public Base {\n    void f() const override {\n    }\n};\n\ntemplate<typename... Args>\nstd::enable_if_t<\n        std::conjunction_v<\n                std::is_base_of<Base, Args>...\n                        >, void>\nInvoke(const std::tuple<Args...> &tup, size_t index) {\n\n}\n\nint main() {\n    std::tuple tu{D1(), D2(), D1()};\n    Invoke(tu, 1);\n}\n\n")),(0,r.kt)("p",null,"\u7136\u800cInvoke\u51fd\u6570\u91ccindex\u662f\u8fd0\u884c\u671f\u53d8\u91cf\uff0c\u4e0d\u80fd\u4f7f\u7528",(0,r.kt)("inlineCode",{parentName:"p"},"std::get<index>"),"\uff0c\u6240\u4ee5\u91c7\u7528",(0,r.kt)("strong",{parentName:"p"},"\u7f16\u8bd1\u671f\u5c55\u5f00"),"\u7684\u65b9\u5f0f"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'struct Base {\n    virtual void f() const = 0;\n};\n\nstruct D1 : public Base {\n    void f() const override {\n        std::cout << "1\\n";\n    }\n};\n\nstruct D2 : public Base {\n    void f() const override {\n        std::cout << "2\\n";\n    }\n};\n\n\ntemplate<int N, typename... Args>\nvoid TryInvoke(const std::tuple<Args...>& tup, size_t index){\n    if constexpr (N < sizeof...(Args)){\n        if(index == N){\n            std::get<N>(tup).f();\n            return;\n        }\n\n        TryInvoke<N + 1, Args...>(tup, index);\n    }\n}\n\ntemplate<typename... Args>\nstd::enable_if_t<\n        std::conjunction_v<\n                std::is_base_of<Base, Args>...\n                        >, void>\nInvoke(const std::tuple<Args...> &tup, size_t index) {\n    if(index >= sizeof...(Args)){\n        return;\n    }\n    TryInvoke<0, Args...>(tup, index);\n}\n\nint main() {\n    std::tuple tu{D1(), D2(), D1()};\n    Invoke(tu, 0);\n    Invoke(tu, 1);\n}\n\n')),(0,r.kt)("p",null,"\u8fd9\u91cc\u7528\u5230\u4e86\u6a21\u7248\u5b9e\u4f8b\u5316\u7684\u9012\u5f52\uff0c\u5728\u7f16\u8bd1\u671f\u9012\u5f52\u751f\u6210\u591a\u4e2a\u6a21\u7248\u51fd\u6570"),(0,r.kt)("h3",{id:"\u5b9e\u73b0\u4e00\u4e2astdinvoke"},"\u5b9e\u73b0\u4e00\u4e2astd::invoke"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename T, typename... Args>\nauto invoke(T&& obj, Args&&... args){\n    return obj(std::forward<Args>(args)...);\n}\n\nvoid f(int a){\n    std::cout << a;\n}\n\nint main(){\n    invoke(f, 4);\n}\n")),(0,r.kt)("h3",{id:"\u5b9e\u73b0\u4e00\u4e2astdapply"},"\u5b9e\u73b0\u4e00\u4e2astd::apply"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename T, typename... Args>\nauto invoke(T&& obj, Args&&... args){\n    return obj(std::forward<Args>(args)...);\n}\n\ntemplate<typename T, typename Tup, size_t... Index>\ndecltype(auto) my_apply(T&& obj, Tup&& tup){\n    return invoke(obj, std::get<Index>(std::forward<Tup>(tup))...);\n}\n\nvoid f(int a, int b){\n    std::cout << a << \" \" << b;\n}\n\nint main(){\n    invoke(f, 4, 5);\n    std::tuple<int, char>tup = {1, 'a'};\n    my_apply<void(*)(int, int),  std::tuple<int, char>, 0, 1>(f, std::move(tup));\n}\n")),(0,r.kt)("p",null,"\u8c03\u7528\u592a\u5570\u55e6\u4e86\uff0c\u9700\u8981\u4e00\u4e2a\u5de5\u5177\u81ea\u52a8\u751f\u6210\u4ece0\u5230N-1\u7684\u5e8f\u5217"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'template<int N, int... Index>\nstruct A : public A<N - 1, N - 1, Index...> {\n\n};\n\ntemplate<int... Index>\nstruct A<0, Index...> {\n    static void printIndex() {\n        ((std::cout << Index << " "), ...);\n    }\n};\n\nint main() {\n    A<5>::printIndex();\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'template <size_t... Index>\nstruct sequence {\n    static void printIndex() {\n        ((std::cout << Index << " "), ...) << std::endl;\n\n    }\n};\n\ntemplate<size_t N, size_t... Index>\nstruct make_sequence : make_sequence<N - 1, N - 1, Index...> {};\n\ntemplate <size_t... Index>\nstruct make_sequence<0, Index...> {\n    using result = sequence<Index...>;\n};\n\ntemplate<typename T, typename... Args>\nauto invoke(T&& obj, Args&&... args) {\n    return obj(std::forward<Args>(args)...);\n}\n\ntemplate<typename T, typename Tup, size_t... Index>\nauto apply_impl(T&& obj, Tup&& tup, sequence<Index...>) {\n    return invoke(std::forward<T>(obj), std::get<Index>(std::forward<Tup>(tup))...);\n}\n\ntemplate<typename T, typename Tup>\nauto my_apply(T&& obj, Tup&& tup) {\n    make_sequence<std::tuple_size_v<std::decay_t<Tup>>>::result::printIndex();\n    typename make_sequence<std::tuple_size_v<std::decay_t<Tup>>>::result res;\n    return apply_impl(std::forward<T>(obj), std::forward<Tup>(tup), res);\n}\n\nvoid f(int a, double b, char c) {\n    std::cout << a << " " << b << " " << c ;\n}\n\nint main() {\n    std::tuple tu{1, 1.4, \'a\'};\n    my_apply(f, tu);\n    return 0;\n}\n')),(0,r.kt)("h3",{id:"\u5b9e\u73b0\u4e00\u4e2avariant"},"\u5b9e\u73b0\u4e00\u4e2avariant"),(0,r.kt)("p",null,"std::variant\u7528\u6cd5"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"struct A{\n    A() = default;\n};\nint main(){\n    std::variant<A, int, char, std::string> var;\n    var = 1;\n    std::cout << var.index();\n}\n")),(0,r.kt)("p",null,"\u53ef\u4ee5\u5b58\u653e\u591a\u79cd\u7c7b\u578b\u4f46\u540c\u4e00\u65f6\u523b\u53ea\u80fd\u5b58\u653e\u4e00\u79cd"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename T1, typename T2>\nclass variant{\npublic:\n    variant(const T1& t1){\n        data.t1 = t1;\n    };\n    variant(const T2& t2){\n        data.t2 = t2;\n    };\n\nprivate:\n    union{\n        T1 t1;\n        T2 t2;\n    }data;\n    int index;\n};\n")),(0,r.kt)("p",null,"\u5bf9\u4e8e\u4efb\u610f\u53c2\u6570\u7684variant\u65e0\u6cd5\u6620\u5c04\u5230union\u4e2d"),(0,r.kt)("p",null,"\u672c\u6765variant\u7684\u76ee\u7684\u5c31\u662f\u590d\u7528\u5185\u5b58\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u81ea\u5df1\u7ba1\u7406\u4e00\u5757\u5185\u5b58"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename... Ts>\nclass variant{\npublic:\n    template<int Index, typename... Args>\n    variant(Args&&... args){\n\n    }\nprivate:\n    void* data = std::malloc(std::max(sizeof(Ts)...));\n    int index;\n};\n\nint main(){\n    variant<1, int> va; //\u65e0\u6cd5\u6b63\u786e\u5b9e\u4f8b\u5316\u6a21\u7248\u7c7b\u7684\u6a21\u7248\u6784\u9020\u51fd\u6570\n}\n")),(0,r.kt)("p",null,"\u7136\u800c\u6a21\u7248\u7c7b\u7684\u6a21\u7248\u6784\u9020\u51fd\u6570\u662f\u4e0d\u80fd\u5b9e\u4f8b\u5316\u7684\uff0c\u56e0\u4e3a\u4f1a\u88ab\u8bc6\u522b\u6210\u7c7b\u6a21\u7248\u53c2\u6570\uff0c\u56e0\u6b64\u6784\u9020\u51fd\u6570\u53ea\u80fd\u4f9d\u8d56\u4e8e\u81ea\u52a8\u63a8\u5bfc"),(0,r.kt)("p",null,"Index\u600e\u4e48\u63a8\u5bfc\u5462 ==> \u4f7f\u7528\u4e00\u4e2ain_place\u6a21\u7248\u7c7b"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<size_t Index>\nstruct in_place_index_t{\n    explicit in_place_index_t() = default;\n};\n\ntemplate<size_t Index>\ninline constexpr in_place_index_t<Index> in_place_index{}\n\n\ntemplate<typename... Ts>\nclass variant{\npublic:\n    template<size_t Index, typename... Args>\n    variant(const in_place_index_t<Index>& index, Args&&... args){\n\n    }\nprivate:\n    void* data = std::malloc(std::max(sizeof(Ts)...));\n    int index;\n};\n\nint main(){\n    variant<int, char> var_int{in_place_index<0>(), 1};\n    variant<int, char> var_char{in_place_index<1>(), 'a'};\n}\n")),(0,r.kt)("p",null,"\u5b9e\u73b0\u6784\u9020\u51fd\u6570\u9700\u8981\uff0cnew \u521b\u5efa\u76f8\u5e94\u7c7b\u578b\u7684\u5bf9\u8c61\uff0c\u5c31\u9700\u8981\u4ece\u9759\u6001\u7684\u6a21\u7248\u53c2\u6570size_t Index\u5230\u5177\u4f53\u7c7b\u578b\u7684\u5de5\u5177, \u989d\u5916\u5b9e\u73b0\u4e86\u4e00\u4e2aget\u65b9\u6cd5"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<size_t Index, typename Head, typename... Types>\nstruct get_type_by_index : get_type_by_index<Index - 1, Types...>{};\n\ntemplate<typename Head, typename... Types>\nstruct get_type_by_index<0, Head, Types...>{\n    using type = Head;\n};\n\ntemplate<typename... Ts>\nclass variant{\npublic:\n    template<size_t Index, typename... Args>\n    variant(const in_place_index_t<Index>& index, Args&&... args){\n        using data_type = std::decay_t<typename get_type_by_index<Index, Ts...>::type>;\n        mData = new data_type(args...);\n        mIndex = Index;\n    }\n\n    int index() const {\n        return index;\n    }\n\n    template<size_t Index>\n    auto get() const {\n        using data_type = std::decay_t<typename get_type_by_index<Index, Ts...>::type>;\n        return *static_cast<data_type*>(mData);\n    }\n\nprivate:\n    void* mData = std::malloc(std::max(sizeof(Ts)...));\n    int mIndex;\n};\n")),(0,r.kt)("p",null,"\u800c\u6790\u6784\u3001\u62f7\u8d1d\u6784\u9020\u3001\u62f7\u8d1d\u8d4b\u503c\u9700\u8981\u4ece\u8fd0\u884c\u65f6\u7684mIndex\u6210\u5458\u53d8\u91cf\u5230\u5177\u4f53\u7c7b\u578b\uff0c\u91c7\u7528",(0,r.kt)("strong",{parentName:"p"},"\u9759\u6001\u7a77\u4e3e\u6240\u6709\u53ef\u80fd\u60c5\u51b5"),"\u7684\u65b9\u5f0f"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename... Ts>\nclass variant {\nprivate:\n    template<typename Type>\n    void destory_data() {\n        delete static_cast<std::add_pointer_t<Type>>(mData);\n    }\n    \n    template<typename Type>\n    void create_data(const void* other_data){\n        new(mData) Type(*static_cast<const Type*>(other_data));\n    }\n    \npublic:\n    ~variant() {\n        std::array<void (variant<Ts...>::*)(), sizeof...(Ts)> destroy_functions = {\n                &variant<Ts...>::destory_data<Ts>...\n        };\n        if(mData != nullptr){\n            (this->*destroy_functions.at(mIndex))();\n        }\n    }\n    \n    variant(const variant& other){\n        std::array<void(variant::*)(const void*), sizeof...(Ts)> create_functions = {\n              &variant::create_data<Ts>...\n        };\n        mIndex = other.mIndex;\n        (this->*create_functions.at(mIndex))(other.mData);\n    }\n\n    variant(variant&& other){\n        mData = other.mData;\n        mIndex = other.mIndex;\n        other.mData = nullptr;\n        other.mIndex = -1;\n    }\n\n    variant& operator=(const variant& other){\n        if(this == &other) return *this;\n        // release data\n        std::array<void (variant::*)(), sizeof...(Ts)> destroy_functions = {\n                &variant::destory_data<Ts>...\n        };\n        (this->*destroy_functions.at(mIndex))();\n\n        // copy assignment\n        std::array<void(variant::*)(const void*), sizeof...(Ts)> create_functions = {\n                &variant::create_data<Ts>...\n        };\n        mIndex = other.mIndex;\n        (this->*create_functions.at(mIndex))(other.mData);\n\n        return *this;\n    }\n\n    variant& operator=(variant&& other){\n        if(this == &other) return *this;\n\n        // release data\n        std::array<void (variant::*)(), sizeof...(Ts)> destroy_functions = {\n                &variant::destory_data<Ts>...\n        };\n        (this->*destroy_functions.at(mIndex))();\n\n        // move assignment\n        mData = other.mData;\n        mIndex = other.mIndex;\n        other.mData = nullptr;\n        other.mIndex = -1;\n\n        return *this;\n    }\n\n}\n")),(0,r.kt)("p",null,"\u7136\u540e\u60f3\u5b9e\u73b0variant<int, char> var(1); \u800c\u4e0d\u901a\u8fc7in_place_index\u6765\u6784\u9020\uff0c\u8fdb\u800c\u53ef\u4ee5\u652f\u6301implicit\u8f6c\u5316\uff0c ",(0,r.kt)("inlineCode",{parentName:"p"},"variant<int, char> var = 1")),(0,r.kt)("p",null,"\u9700\u8981\u4e00\u4e2a\u5de5\u5177\u4ecetype ==> index"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template <typename Target, typename Head, typename... Ts>\nstruct get_index_from_types {\n    constexpr static size_t value = get_index_from_types<Target, Ts...>::value + 1;\n};\n\ntemplate <typename Target, typename... Ts>\nstruct get_index_from_types<Target, Target, Ts...>{\n    constexpr static size_t value = 0;\n};\n\nstd::cout << get_index_from_types<Test1, int, char, std::string, Test1>::value;\n\ntemplate<typename T>\n    variant(T&& t){\n        constexpr size_t index = get_index_from_types<T, Ts...>::value;\n        new(mData) T(std::forward<T>(t));\n        mIndex = index;\n}\n\ntemplate<typename Type>\n    auto get() const {\n        constexpr size_t index = get_index_from_types<Type, Ts...>::value;\n        return get<index>();\n    }\n\n")),(0,r.kt)("p",null,"\u5b8c\u6574\u4ee3\u7801"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"//\n// Created by ChenhuiWang on 2024/4/3.\n\n// Copyright (c) 2024 Tencent. All rights reserved.\n//\n#include <iostream>\n#include <array>\n\n\ntemplate<size_t Index>\nstruct in_place_index_t {\n    explicit in_place_index_t() = default;\n};\n\ntemplate<size_t Index>\ninline constexpr in_place_index_t<Index> in_place_index{};\n\ntemplate<size_t Index, typename Head, typename... Types>\nstruct get_type_by_index : get_type_by_index<Index - 1, Types...> {\n};\n\ntemplate<typename Head, typename... Types>\nstruct get_type_by_index<0, Head, Types...> {\n    using type = Head;\n};\n\ntemplate <typename Target, typename Head, typename... Ts>\nstruct get_index_from_types {\n    constexpr static size_t value = get_index_from_types<Target, Ts...>::value + 1;\n};\n\ntemplate <typename Target, typename... Ts>\nstruct get_index_from_types<Target, Target, Ts...>{\n    constexpr static size_t value = 0;\n};\n\n\n\ntemplate<typename... Ts>\nclass variant {\npublic:\n    template<size_t Index, typename... Args>\n    variant(const in_place_index_t<Index> &index, Args &&... args) {\n        using data_type = std::decay_t<typename get_type_by_index<Index, Ts...>::type>;\n        new(mData) data_type(args...);\n        mIndex = Index;\n    }\n\n    template<typename T>\n    variant(T&& t){\n        constexpr size_t index = get_index_from_types<T, Ts...>::value;\n        new(mData) T(std::forward<T>(t));\n        mIndex = index;\n    }\n\n    ~variant() {\n        std::array<void (variant::*)(), sizeof...(Ts)> destroy_functions = {\n                &variant::destory_data<Ts>...\n        };\n        if(mData != nullptr){\n            (this->*destroy_functions.at(mIndex))();\n        }\n    }\n\n    variant(const variant& other){\n        std::array<void(variant::*)(const void*), sizeof...(Ts)> create_functions = {\n              &variant::create_data<Ts>...\n        };\n        mIndex = other.mIndex;\n        (this->*create_functions.at(mIndex))(other.mData);\n    }\n\n    variant(variant&& other){\n        mData = other.mData;\n        mIndex = other.mIndex;\n        other.mData = nullptr;\n        other.mIndex = -1;\n    }\n\n    variant& operator=(const variant& other){\n        if(this == &other) return *this;\n        // release data\n        std::array<void (variant::*)(), sizeof...(Ts)> destroy_functions = {\n                &variant::destory_data<Ts>...\n        };\n        (this->*destroy_functions.at(mIndex))();\n\n        // copy assignment\n        std::array<void(variant::*)(const void*), sizeof...(Ts)> create_functions = {\n                &variant::create_data<Ts>...\n        };\n        mIndex = other.mIndex;\n        (this->*create_functions.at(mIndex))(other.mData);\n\n        return *this;\n    }\n\n    variant& operator=(variant&& other){\n        if(this == &other) return *this;\n\n        // release data\n        std::array<void (variant::*)(), sizeof...(Ts)> destroy_functions = {\n                &variant::destory_data<Ts>...\n        };\n        (this->*destroy_functions.at(mIndex))();\n\n        // move assignment\n        mData = other.mData;\n        mIndex = other.mIndex;\n        other.mData = nullptr;\n        other.mIndex = -1;\n\n        return *this;\n    }\n\n    int index() const {\n        return index;\n    }\n\n    template<size_t Index>\n    auto get() const {\n        assert(Index == mIndex);\n        using data_type = std::decay_t<typename get_type_by_index<Index, Ts...>::type>;\n        return *static_cast<data_type *>(mData);\n    }\n\n    template<typename Type>\n    auto get() const {\n        constexpr size_t index = get_index_from_types<Type, Ts...>::value;\n        return get<index>();\n    }\n\nprivate:\n    void *mData = std::malloc(std::max(sizeof(Ts)...));\n    int mIndex;\n\n    template<typename Type>\n    void destory_data() {\n        delete static_cast<Type*>(mData);\n    }\n\n\n    template<typename Type>\n    void create_data(const void* other_data){\n        new(mData) Type(*static_cast<const Type*>(other_data));\n    }\n};\n\n\nstruct Test1{\n    ~Test1(){\n        std::cout << \"~Test1()\" << std::endl;\n    }\n};\nstruct Test2{\n    ~Test2(){\n        std::cout << \"~Test2()\" << std::endl;\n    }\n};\n\nint main() {\n    variant<Test1, Test2> var1(in_place_index<0>);\n//    variant<Test1, Test2> var2(var1);\n//\n//    std::variant<short, int> v = 1;\n//    std::cout << v.index();\n//    std::cout << get_index_from_types<int, int>::value;\n//\n//    std::cout << get_index_from_types<Test1, int, char, std::string, Test1>::value;\n\n    struct A{\n        A(int m, char n) : m(m), n(n) {}\n        int m;\n        char n;\n    };\n\n//    std::variant<int, A> v(A{1, 'c'});\n//    v = A{2, 'a'};\n\n    variant<int, A> var3(A{1, 'c'});\n    var3 = A{2, 'a'};\n    std::cout << var3.get<A>().m;\n    std::cout << var3.get<0>();\n\n    std::variant<int, char> a(std::in_place_index<0>, 3);\n}\n")))}c.isMDXComponent=!0}}]);